from sage.all import *
import re
import time
from multiprocessing import Pool, Value
import multiprocessing
import itertools
import datetime
import time
import os
import ast
import string
import glob
import subprocess

def findAnyPCN_polynom(p,r,n, factors=None):
    #if r == 1:
    return findAnyPCN_polynom_prime(p,r*n,factors)

    q = p**r
    F = GF(q,'a')

    E = F.extension(n,'a')
    P = E.prime_subfield()

    Px = PolynomialRing(P,'x')
    Fx = PolynomialRing(F,'x')
    Ex = PolynomialRing(E,'x')
    h = Hom(F,E)[0]
    primOrder = E.order()-1
   
    primitives = []
    
    #setup factors of x^n-1
    divs = get_proper_subfield_divisors(p,r,n)
    facsAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    for d in divs:
        G = F.extension(Integer(d), 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facsAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facsAll[d]):
            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]

    # list elements of F
    Flist = [F.zero()]
    for i in xrange(1,r+1):
        for idcs in itertools.combinations(xrange(0,r),i):
            for koeffs in itertools.product(xrange(1,p),repeat=i):
                Flist += [F(list(sum([e * Px.gen()**idcs[j] for \
                        j,e in enumerate(reversed(koeffs))])))]

    if not is_even(n):
        FprimList = [F.zero()]
        for i in xrange(1,r+1):
            for idcs in itertools.combinations(xrange(0,r),i):
                for koeffs in itertools.product(xrange(p-1,0,-1),repeat=i):
                    FprimList += [F(list(sum([e * Px.gen()**idcs[j] for \
                            j,e in enumerate(reversed(koeffs))])))]

    firstRun = True
    # first test trinoms!
    for coeffT in xrange(1,q):
        coeffTF = Flist[coeffT]
        if firstRun:
            for coeffN in xrange(p,q):
                if is_even(n):
                    coeffNF = Flist[coeffN]
                else:
                    coeffNF = FprimList[coeffN]
                if coeffNF.multiplicative_order() != F.order()-1: continue
                if not is_even(n): coeffNF *= (-1)
                primitives += [coeffNF]
                f = Fx.gen()**n + coeffTF*Fx.gen()**(n-1) + coeffNF
                #print f
                if not f.is_irreducible(): continue
                for fac,mul in Ex(f.map_coefficients(h)).factor():
                    if fac.degree() == 1:
                        x = -fac[0]
                        if x.multiplicative_order() == primOrder \
                                and isCompletelyNormal(x,E,q,divs,\
                                fieldsAll,facsAll,prodsAll):
                            #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
                                #"prim: ", (x.multiplicative_order() == E.order()-1)
                            return f
                        else: break
                    else: break
            firstRun = False
        else:
            for coeffNF in primitives:
                f = Fx.gen()**n + coeffTF*Fx.gen()**(n-1) + coeffNF
                #print "not first:",f
                if not f.is_irreducible(): continue
                for fac,mul in Ex(f.map_coefficients(h)).factor():
                    if fac.degree() == 1:
                        x = -fac[0]
                        if x.multiplicative_order() == primOrder \
                                and isCompletelyNormal(x,E,q,divs,\
                                fieldsAll,facsAll,prodsAll):
                            #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
                                #"prim: ", (x.multiplicative_order() == E.order()-1)
                            return f
                        else: break
                    else: break
    # test rest
    for length in xrange(1,n-1):
        for idcs in itertools.combinations(xrange(1,n-1),length):
            for xs in itertools.product(xrange(1,q),repeat=length+1):
                for x in primitives:
                    f = Fx.gen()**n + Flist[xs[0]]*Fx.gen()**(n-1) + x
                    for j,j2 in enumerate(idcs):
                        f += Flist[xs[length-j]] * Fx.gen() ** j2
                    #print f
                    if not f.is_irreducible(): continue
                    for fac,mul in Ex(f.map_coefficients(h)).factor():
                        if fac.degree() == 1:
                            y = -fac[0]
                            if y.multiplicative_order() == primOrder \
                                    and isCompletelyNormal(y,E,q,divs,\
                                    fieldsAll,facsAll,prodsAll):
                                #print "x = ",y,"\tcn: ",isCompletelyNormal(y,F),\
                                    #"prim: ", (y.multiplicative_order() == E.order()-1)
                                return f
                            else: break
                        else: break

# special function for testing extensions of PrimeFields
# if factors != None assume factors is a list containing the complete
# factorization of p**n-1
def findAnyPCN_polynom_prime(p,n,factors=None):
    p = Integer(p)
    n = Integer(n)
    F = GF(p)
    
    Fx = PolynomialRing(F,'x')
    
    orderE = p**n
    primOrder = orderE-1

    primitives = []

    #setup barFactors 
    barFactors = None
    if factors != None:
        barFactors = []
        for i,(fac,mul) in enumerate(factors):
            barFactors += [prod( map(lambda fm: fm[0]**fm[1],
                    factors[:i] + [(fac,mul-1)] + factors[i+1:] ))]


    #setup factors of x^n-1
    divs = get_proper_subfield_divisors(p,1,n)
    facsAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    for d in divs:
        G = F.extension(Integer(d), 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facsAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facsAll[d]):
            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]

    firstRun = True
    # first test trinoms!
    for coeffT in xrange(1,p):
        if firstRun:
            if is_even(n):
                prange = xrange(1,p)
            else:
                prange = xrange(p-1,0,-1)
            for coeffN in prange:
                if F(coeffN).multiplicative_order() != p-1: continue
                if is_even(n):
                    primitives += [coeffN]
                else:
                    coeffN *= (-1)
                    primitives = [coeffN] + primitives
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                #print f
                if not f.is_irreducible(): continue
                
                E = GF(orderE, name='a', modulus=f)

                if isPrimitive(E.gen(), barFactors) \
                        and isCompletelyNormal(E.gen(),E,p,\
                            divs,fieldsAll,facsAll,prodsAll):
                    return f
            firstRun = False
        else:
            #print primitives
            for coeffN in primitives:
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                #print "not first:",f
                #print f,"\t\t",numsf(f)
                if not f.is_irreducible(): continue
                E = GF(orderE, name='a', modulus=f)

                if isPrimitive(E.gen(),barFactors) \
                        and isCompletelyNormal(E.gen(),E,p,\
                            divs,fieldsAll,facsAll,prodsAll):
                    return f
    # test rest
    for length in xrange(1,n-1):
        for idcs in itertools.combinations(xrange(1,n-1),length):
            #print idcs
            for xs in itertools.product(xrange(1,p),repeat=length+1):
                #print xs
                for x in primitives:
                    f = Fx.gen()**n + xs[0]*Fx.gen()**(n-1) + x
                    for j,j2 in enumerate(idcs):
                        f += xs[length-j] * Fx.gen() ** j2
                    #print f
                    if not f.is_irreducible(): continue
                    E = GF(orderE, name='a', modulus=f)

                    if isPrimitive(E.gen(),barFactors) \
                            and isCompletelyNormal(E.gen(),E,p,\
                                divs,fieldsAll,facsAll,prodsAll):
                        return f


# tests x for primitivity
def isPrimitive(x,barFactors=None):
    if barFactors==None:
        return x.multiplicative_order() == x.parent().order()-1
    else:
        for b in barFactors:
            if x**b == x.parent().one(): return False
        return True



def findAnyPCN_polynom_wrapper(n, border=lambda n:n**4, \
        fileoutput=False, filepath="pcns_trinom_", \
        startPrime=1, stopPrime=0, onlyR=None, \
        cpuNum=1):
    if fileoutput:
        st = datetime.datetime.\
                fromtimestamp(time.time()).strftime('%Y-%m-%d_%H:%M:%S')
        filepath += str(n)+"_"
        if onlyR != None: filepath += str(onlyR)+"_"
        filepath += st
    border = border(n)
    p = startPrime
    if onlyR != None and p**onlyR > border: return

    gen = runGenerator(border,[startPrime,stopPrime],[onlyR,onlyR])
    pool = Pool(cpuNum)
    for p,r,n,pol in pool.imap( findAnyPCN_polynom__star, \
            ((p,r,n) for p,r in gen) ):
        print "(",p,", ",r,") = ", pol
        if fileoutput:
            with open(filepath,'a') as f:
                f.write(str(p)+"\t"+str(r)
                        +"\t"+str(pol)+"\n")
            f.close();
    pool.close()
    pool.join()


def findAnyPCN_polynom_wrapper_const_p(n, p, border=lambda n:n**4, \
        fileoutput=False, filepath="pcns_trinom_", \
        startR=2, \
        cpuNum=1):
    if fileoutput:
        st = datetime.datetime.\
                fromtimestamp(time.time()).strftime('%Y-%m-%d_%H:%M:%S')
        filepath += str(n)+"_"
    border = border(n)
    
    gen = runGenerator(border,[p-1,p], [startR,100])
    pool = Pool(cpuNum)
    for p,r,n,(x,pol) in pool.imap_unordered( findAnyPCN_polynom__star, \
            ((p,r,n) for p,r in gen) ):
        print "(",p,", ",r,") = ", pol
        if fileoutput:
            with open(filepath+str(r)+"_"+st,'a') as f:
                f.write(str(p)+"\t"+str(r)
                        +"\t"+str(pol)+"\n")
            f.close();
    pool.close()
    pool.join()

def findAnyPCN_polynom__star(prn):
    return prn[0],prn[1],prn[2],findAnyPCN_polynom(*prn)


def runGenerator(border,pRange=None,rRange=None):
    if pRange == None:
        p = 1
    else:
        p = pRange[0]
    while p < border :
        p = next_prime(p)
        if pRange != None and p > pRange[1]: return
        # consider only rs in rRange
        if rRange != None:
            for r in xrange(rRange[0],rRange[1]+1):
                if p**r > border: break
                yield p,r
        # consider all rs
        else:
            r = 1
            q = p**r
            while q < border:
                yield p,r
                r += 1
                q = p**r




def goodBorder(n):
    n = Integer(n)
    return ceil(find_root( \
            var('q') == \
            1/log(2)*( sum(divisors(n))-1 )*(log(2) + n*log(var('q'))), \
            1, n**4 ))


# checks if a PCN elements exists by
# checking the inequality
# |P| >= |H| - 1 
# where H is estimated
def numericExistence(p,r,n, factors=[]):
    p = Integer(p)
    r = Integer(r)
    n = Integer(n)
    q = p**r
    qn = q**n
    
    if isRegular(p,r,1,n,1):
        return "Regular"
    
    # calc not normals
    divs = get_proper_subfield_divisors(p,r,n)
    notnorms = sum([ n/k*(q**(n-k)-1) for k in divs ])
    #print "notnorms = %E"%notnorms
    #print "notnorms = ",notnorms

    # check approx primitives
    #print "approx 1 = %E"%(log(2)*(qn-1)/log(2*(qn-1)))
    #if log(2)*(qn-1)/log(2*(qn-1)) > notnorms: 
        #return True
    

    # check approximation for euler_phi:
    # euler_phi(n) >= n/( e^gamma * loglog n + 3/loglog n ) 
    #print "approx 2 = %E"%((qn-1) / ( e**euler_gamma * log(log(qn-1)) + 3/log(log(qn-1))))
    #print "approx 2 = ",round((qn-1) / ( e**euler_gamma * log(log(qn-1)) + 3/log(log(qn-1))),3)
    if (qn-1) / ( e**euler_gamma * log(log(qn-1)) + 3/log(log(qn-1)) ) > notnorms:
        return True

    # calc primitives
    # using q**n-1 = prod_(d|r*n) Phi_d(p)
    Zx = PolynomialRing(ZZ,'x')
    for d in divisors(r*n):
        #print "d=",d," f=",Zx.cyclotomic_polynomial(d),\
                #" -> f(p)=",Zx.cyclotomic_polynomial(d)(p)
        phi = Zx.cyclotomic_polynomial(d)(p)
        # test all primes already computed
        facs = list(factors)  #first copy list
        for s,t in facs: 
            i = 0
            while s.divides(phi): 
                i += 1
                phi /= s
            if i > 0: 
                #print "old factor ",s," reused!"
                factors += [(s,i)]
        # no more "good" factors are known, so factor phi with msieve
        factors += factor_msieve(phi)
        _organizeFactorization(factors)
        #print "factors = ", factors
        prims = 1
        for (f,mul) in factors:
            prims *= f**(mul-1)*(f-1)
            if prims > notnorms: return True
        #print "prims = ",prims
    #print "prims = %E"%prims
    #print "prims2 = %E"%prims2
        #if prims > notnorms: return True
    # check factorization
    #if prod(map(lambda pr: pr[0]**pr[1], factors)) != qn-1:
        #print "FATAL ERROR on ",(p,r,n)," with factors = ",factors
    return False

def _organizeFactorization(fac):
    prims = []
    ret = []
    for (p,mul) in fac:
        if not p in prims:
            prims += [p]
            ret += [(p,mul)]
        else:
            ret[prims.index(p)] = (p,ret[prims.index(p)][1] + mul)
    fac[:] = []
    fac += sorted(ret)


def iterateNumericExistence(n):
    border = goodBorder(n)
    for q in itertools.count(2):
        if q > border: return
        fac = list(factor(q))
        if len(fac) == 1:
            p = fac[0][0]
            r = fac[0][1]
            print p,r,"\t=>",numericExistence(p,r,n)
            if not numericExistence(p,r,n):
                print "\t", findAnyPCN_polynom(p,r,n)[1]

def primePowerGenerator(n,startq=None):
    border = goodBorder(n)
    for q in itertools.count(2):
        if startq != None and q < startq: continue
        if q > border: return
        fac = list(factor(q))
        if len(fac) == 1:
            p = fac[0][0]
            r = fac[0][1]
            yield p,r

def findAnyPCN_polynom_numeric_approx__star(prn):
    p = prn[0]
    r = prn[1]
    n = prn[2]
    factors = []
    
    numEx = numericExistence(prn[0],prn[1],prn[2],factors)
    if numEx != False:
        return prn[0],prn[1],prn[2],numEx,factorization2string(factors)
    else: 
        return prn[0],prn[1],prn[2],\
                findAnyPCN_polynom(prn[0],prn[1],prn[2],factors),\
                factorization2string(factors)



def findAnyPCN_numeric_approx(n, startq=None, \
        fileoutput=False, filepath="out/pcns_trinom_v1.1_", \
        cpuNum=1):
    if fileoutput:
        st = datetime.datetime.\
                fromtimestamp(time.time()).strftime('%Y-%m-%d_%H:%M:%S')
        filepath += str(n)+"_"+st
    
    gen = primePowerGenerator(n,startq)
    pool = Pool(cpuNum)
    for p,r,n,pol,facs in pool.imap_unordered( \
            findAnyPCN_polynom_numeric_approx__star, \
            ((p,r,n) for p,r in gen) ):
        print "(",p,", ",r,", ",n,") = ", pol,"\t"
        if fileoutput:
            with open(filepath,'a') as f:
                f.write(str(p)+"\t"+str(r) \
                        +"\t"+str(pol)+"\t"+facs+"\n")
            f.close();
    pool.close()
    pool.join()



##############################################################################
## Correct data in files #####################################################
##############################################################################


def checkData(inFolder="./out/"):
    ns = []
    for fin in glob.glob(inFolder+"pcns_trinom_*"):
        ns += [Integer(re.compile("pcns_trinom_(\d+)").search(fin).groups()[0])]
    ns = uniq(ns)
    for n in ns:
        checkFiles(glob.glob(inFolder+"pcns_trinom_"+str(n)+"_*"))


def checkFiles(files, outpath="./final/pcns_"):
    data = []
    for fin in files:
        n = Integer(re.compile("pcns_trinom_(\d+)").search(fin).groups()[0])
        with open(fin) as f:
            for line in f:
                if all(c in string.whitespace for c in line): continue
                regroups = re.compile("(\d+)\s+(\d+)\s+(.+)$").search(line).groups()
                p = Integer(regroups[0])
                r = Integer(regroups[1])
                res = regroups[2]
                if isRegular(p,r,1,n,1):
                    res = "Regular"
                data += [(p,r,res)]
                #print "p=",p,"\t","r=",r,"\tres=",res
    toCheck = list(primePowerGenerator(n))
    data = sorted(data)
    fout = outpath+str(n)+".csv"
    with open(fout,'w') as f:
        f.write("p,\tr,\tresult\n")
        for p,r,res in data:
            try:
                toCheck.remove((p,r))
            except:
                print "Error on removing (p,r,n)=",(p,r,n)," on file ",files
            f.write(str(p)+",\t"+str(r)+",\t"+str(res)+"\n")
    f.close()

    print "n = ",n," missing = ",toCheck
    if len(toCheck) > 0:
        fout = outpath+"missing_"+str(n)
        with open(fout,'w') as f:
            for p,r in toCheck:
                f.write(str(p)+",\t"+str(r))
        f.close()





##############################################################################
## Slow Py Algorithms ########################################################
##############################################################################


# Tests x as Element of E on complete normality, i.e. tests for each 
# d in divs, if the corresponding polynomials in prodsAll over the corresponding
# field in fieldsAll vanishes on frobenius evaluation of x.
# fieldsAll and facsAll are dicts indexed by the divisors of divs, where
# fieldsAll[d] is the corresponding intermediate field of order q^d
# and facsAll[d] is the factorization of x^(n/d)-1 over GF(q^d).
# prodsAll[d] is the list of all possible cofactors of above factorization.
def isCompletelyNormal(x,E, q, divs, fieldsAll, facsAll, prodsAll):
    if x == E.zero(): return False
    #test isNormal for each divisor
    pows = dict()
    for d in divs:
        h = Hom(fieldsAll[d],E)[0];
        for idx,(f,mult) in enumerate(facsAll[d]):
            g = prodsAll[d][idx];
            ret = E.zero();
            iold = 0
            xiold = x
            for i,gi in enumerate(list(g)):
                if pows.has_key(i*d):
                    xi = pows[i*d];
                    iold = i*d
                    xiold = xi
                else:
                    xi = xiold**(q**(d*i-iold));
                    pows[i*d] = xi;
                    xiold = xi
                    iold = i*d
                ret += h(gi)*xi
            if ret == 0: return False;
    return True


##############################################################################
## Helper ####################################################################
##############################################################################


def get_padic_representation(number, p):
    number = Integer(number)
    p = Integer(p)
    ret = []
    q = number
    while q > 0:
        q,r = q.quo_rem(Integer(p));
        ret += [r]
    return list(reversed(ret))



# computes the quadratic free part of an integer
def squarefree(n):
    return sage.all.prod(map(lambda x: x[0], sage.all.factor(Integer(n))))

# computes ordn m(q) = min{ k: q ** k = 1 mod m }
def ordn(m,q):
    Zn = IntegerModRing(m)
    return Zn(q).multiplicative_order()

# Application of the Decomposition Theorem (Section 19)
# for x^n-1 over F_p^e
def decompose(p,e, n):
    pi = largestDiv(p,n)
    return decompose_cycl_module(p,e, 1, n/pi, pi)


## returns the module characters of a decomposition
## the module character of U_F,Phi_k(x^t) is k*t / nu(k)
def get_module_characters(decomp):
   return uniq(map(lambda l: l[0]*l[1]*l[2] / squarefree(l[0]),decomp))

# returns the module characters of a cyclotomic module
# the module character of U_F,Phi_k(x^t)^pi is k*t*pi / nu(k)
def get_module_character(k,t,pi):
    return Integer(k*t*pi/squarefree(k))

# returns all divisors of the module characters of an extension
# capped with the complete basic divisors
# i.e. all intermediate fields that must be considered
def get_proper_subfield_divisors(p,e, n):
    basList = get_not_completely_basic_divisors(p,e,n)
    return filter(lambda d: d in basList, \
            list(uniq(itertools.chain(*map(divisors,\
           get_module_characters(decompose(p,e,n)))))))


# internal application of the Decomposition Theorem
# for Phi_k(x^(t*pi)) over F_p^e
def decompose_cycl_module(p,e, k,t,pi):
    if p.divides(k*t): print "ERROR p | kt"
    #test all prime divisors, start with largest one
    flag = False
    for r,l in reversed(factor(t)):
        if not (r**l).divides(ordn(squarefree(k*t),p**e)):
            R = largestDiv(r,t)
            return decompose_cycl_module(p,e, k, t/r, pi) + decompose_cycl_module(p,e, k*R, t/R, pi)
    return [(k,t,pi)]



# returns the largest power of p dividing n
def largestDiv(p,n):
    l = 0
    while (p**l).divides(n):
        l = l+1
    return p**(l-1);


# returns the NOT completely basic divisors of an 
# extension n over GF(p^e)
def get_not_completely_basic_divisors(p,e,n):
    n = Integer(n)
    q = Integer(p**e)
    divs = []
    divsN = divisors(n)
    while len(divsN) > 0:
        d = divsN.pop(0)
        #print "d=",d
        isComplBasic = True
        for r in prime_divisors(n/d):
            #print "\tr=",r
            #print "\t\t (n/d/r)\'=",p_free_part(n/d/r,p)," ordn(_,q^d)=",\
                          #ordn(p_free_part(n/d/r,p),q**d)
            if r.divides(ordn(p_free_part(n/d/r,p),q**d)):
                #print "\t\t=> r | _"
                isComplBasic = False
                break
        divs += [d]
        if isComplBasic: 
            #print "\t -> compl basic!"
            divsN = filter(lambda k: not d.divides(k), divsN)
            #print "\t new divsN=",divsN
    return divs


# p-free part of t
def p_free_part(t,p):
    while p.divides(t):
        t /= p
    return t

# tests if cyclotomic module C_k,t is regular over F_p^e
def isRegular(p,e, k,t,pi):
    return gcd( ordn( squarefree(k*p_free_part(t,p)), p**e ),  k*t*pi) == 1



# formats timedelta objects to nice string
def strfdelta(tdelta):
    d = {}
    d["hours"], rem = divmod(tdelta.seconds, 3600)
    d["hours"] += int(tdelta.days*24)
    d["minutes"], d["seconds"] = divmod(rem, 60)
    return "{hours}:{minutes}:{seconds}".format(**d)



def tau_order(x,F, factors=[], prods=[], sigmaPower=1):
    Fx = PolynomialRing(F,'x');
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    if factors == []:
        fac = (Fx.gen()**n-1).factor();
    else:
        fac = factors;
    pows = dict();
    pre = [];
    for idx,(f,mult) in enumerate(fac):
        for j in xrange(mult-1,-1,-1):
            g = f.parent().one();
            ev = pre + [j] + map(lambda i: i[1], fac[idx+1:]);
            if prods == []:
                #generate factor
                for kidx, k in enumerate(ev):
                    g *= fac[kidx][0]**k;
            else:
                g = prods[str(ev)];
            ret = E.zero();
            for i,g in enumerate(list(g)):
                if pows != []:
                    if pows.has_key(i):
                        xi = pows[i];
                    else:
                        xi = x**(q**i);
                        pows[i] = xi;
                else: xi = x**(q**i);
                try:
                    ret += g*xi;
                except:
                    h = Hom(F,E)[0];
                    ret += h(g)*xi;
            if ret != 0:
                pre += [j+1]; 
                break;
            elif j == 0: 
                pre += [0];
    if prods == []:
        g = f.parent().one();
        for jidx, j in enumerate(pre):
            g *= fac[jidx][0]**j;
    else:
        g = prods[str(pre)]
    gshifted = [Fx.zero()]*len(list(g))
    for i, gi in enumerate(g):
        if gi == 0: continue
        gshifted[int(i/sigmaPower)] = gi
    return Fx(gshifted)


##############################################################################
## Factorization Methods #####################################################
##############################################################################

# Factors n with msieve
#
# returns a list of tuples (p,r) representing the complete factorization of
# n where all p's are distinct primes
#
# msieve must be installed and in PATH!
def factor_msieve(n, msieve_tmp_folder="./msieve_tmp/"):
    #print "call msieve -n -v -q "+str(n)
    if not os.path.exists(msieve_tmp_folder):
        os.mkdir(msieve_tmp_folder)
    tstmp = time.time()
    try:
        s = subprocess.check_output(["msieve","-e","-n","-v","-q",\
                "-s", msieve_tmp_folder+"msieve_"+str(tstmp)+".dat",\
                str(n)], \
                stderr=subprocess.STDOUT)
        #print "got ",s," from msieve -n -v -q "+str(n)
        prime_factors = []
        factorization = []
        for l in s.split("\n"):
            match = re.search("^p\S+: (\d+)$",l)
            if match:
                p = Integer(match.groups()[0])
                if p == 1: continue
                if p in prime_factors:
                    idx = prime_factors.index(p)
                    factorization[idx] = \
                            (p,factorization[idx][1]+1)
                else:
                    prime_factors += [p]
                    factorization += [(p,1)]
        purge(msieve_tmp_folder,"msieve_"+str(tstmp)+".dat*")
        return factorization
    except:
        print "ERROR on :"
        print "\t msieve -n -e -v -q "+str(n)
        return list(factor(n,algorithm='ecm'))


def factorization2string(factorization):
    if factorization == []: return ""
    s = ""
    for idx, (p,r) in enumerate(factorization):
        s += str(p)
        if r > 1: 
            s += "^"+str(r)
        if idx < len(factorization) - 1:
            s += " * "
    return s


def purge(dir, pattern):
    for f in os.listdir(dir):
        if re.search(pattern, f):
            os.remove(os.path.join(dir, f))

