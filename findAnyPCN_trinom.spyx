from sage.all import *
import re
import time
from multiprocessing import Pool, Value
import multiprocessing
import multiprocessing.pool
import itertools
import datetime
import time
import os
import ast
import string
import glob
import subprocess
import yafu

def findAnyPCN_polynom(p,r,n, factors=None):
    #if r == 1:
    return findAnyPCN_polynom_prime(p,r*n,factors)

    q = p**r
    F = GF(q,'a')

    E = F.extension(n,'a')
    P = E.prime_subfield()

    Px = PolynomialRing(P,'x')
    Fx = PolynomialRing(F,'x')
    Ex = PolynomialRing(E,'x')
    h = Hom(F,E)[0]
    primOrder = E.order()-1
   
    primitives = []
    
    #setup factors of x^n-1
    divs = get_proper_subfield_divisors(p,r,n)
    facsAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    for d in divs:
        G = F.extension(Integer(d), 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facsAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facsAll[d]):
            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]

    # list elements of F
    Flist = [F.zero()]
    for i in xrange(1,r+1):
        for idcs in itertools.combinations(xrange(0,r),i):
            for koeffs in itertools.product(xrange(1,p),repeat=i):
                Flist += [F(list(sum([e * Px.gen()**idcs[j] for \
                        j,e in enumerate(reversed(koeffs))])))]

    if not is_even(n):
        FprimList = [F.zero()]
        for i in xrange(1,r+1):
            for idcs in itertools.combinations(xrange(0,r),i):
                for koeffs in itertools.product(xrange(p-1,0,-1),repeat=i):
                    FprimList += [F(list(sum([e * Px.gen()**idcs[j] for \
                            j,e in enumerate(reversed(koeffs))])))]

    firstRun = True
    # first test trinoms!
    for coeffT in xrange(1,q):
        coeffTF = Flist[coeffT]
        if firstRun:
            for coeffN in xrange(p,q):
                if is_even(n):
                    coeffNF = Flist[coeffN]
                else:
                    coeffNF = FprimList[coeffN]
                if coeffNF.multiplicative_order() != F.order()-1: continue
                if not is_even(n): coeffNF *= (-1)
                primitives += [coeffNF]
                f = Fx.gen()**n + coeffTF*Fx.gen()**(n-1) + coeffNF
                #print f
                if not f.is_irreducible(): continue
                for fac,mul in Ex(f.map_coefficients(h)).factor():
                    if fac.degree() == 1:
                        x = -fac[0]
                        if x.multiplicative_order() == primOrder \
                                and isCompletelyNormal(x,E,q,divs,\
                                fieldsAll,facsAll,prodsAll):
                            #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
                                #"prim: ", (x.multiplicative_order() == E.order()-1)
                            return f
                        else: break
                    else: break
            firstRun = False
        else:
            for coeffNF in primitives:
                f = Fx.gen()**n + coeffTF*Fx.gen()**(n-1) + coeffNF
                #print "not first:",f
                if not f.is_irreducible(): continue
                for fac,mul in Ex(f.map_coefficients(h)).factor():
                    if fac.degree() == 1:
                        x = -fac[0]
                        if x.multiplicative_order() == primOrder \
                                and isCompletelyNormal(x,E,q,divs,\
                                fieldsAll,facsAll,prodsAll):
                            #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
                                #"prim: ", (x.multiplicative_order() == E.order()-1)
                            return f
                        else: break
                    else: break
    # test rest
    for length in xrange(1,n-1):
        for idcs in itertools.combinations(xrange(1,n-1),length):
            for xs in itertools.product(xrange(1,q),repeat=length+1):
                for x in primitives:
                    f = Fx.gen()**n + Flist[xs[0]]*Fx.gen()**(n-1) + x
                    for j,j2 in enumerate(idcs):
                        f += Flist[xs[length-j]] * Fx.gen() ** j2
                    #print f
                    if not f.is_irreducible(): continue
                    for fac,mul in Ex(f.map_coefficients(h)).factor():
                        if fac.degree() == 1:
                            y = -fac[0]
                            if y.multiplicative_order() == primOrder \
                                    and isCompletelyNormal(y,E,q,divs,\
                                    fieldsAll,facsAll,prodsAll):
                                #print "x = ",y,"\tcn: ",isCompletelyNormal(y,F),\
                                    #"prim: ", (y.multiplicative_order() == E.order()-1)
                                return f
                            else: break
                        else: break

# special function for testing extensions of PrimeFields
# if factors != None assume factors is a list containing the complete
# factorization of p**n-1
def findAnyPCN_polynom_prime(p,n,factors=None):
    p = Integer(p)
    n = Integer(n)
    F = GF(p)
    
    Fx = PolynomialRing(F,'x')
    
    orderE = p**n
    primOrder = orderE-1

    primitives = []

    #setup barFactors 
    barFactors = None
    if factors != None:
        barFactors = []
        for i,(fac,mul) in enumerate(factors):
            barFactors += [prod( map(lambda fm: fm[0]**fm[1],
                    factors[:i] + [(fac,mul-1)] + factors[i+1:] ))]


    #setup factors of x^n-1
    divs = get_proper_subfield_divisors(p,1,n)
    facsAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    for d in divs:
        G = F.extension(Integer(d), 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facsAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facsAll[d]):
            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]

    firstRun = True
    # first test trinoms!
    for coeffT in xrange(1,p):
        if firstRun:
            if is_even(n):
                prange = xrange(1,p)
            else:
                prange = xrange(p-1,0,-1)
            for coeffN in prange:
                if F(coeffN).multiplicative_order() != p-1: continue
                if is_even(n):
                    primitives += [coeffN]
                else:
                    coeffN *= (-1)
                    primitives = [coeffN] + primitives
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                #print f
                if not f.is_irreducible(): continue
                
                E = GF(orderE, name='a', modulus=f)

                if isPrimitive(E.gen(), barFactors) \
                        and isCompletelyNormal(E.gen(),E,p,\
                            divs,fieldsAll,facsAll,prodsAll):
                    return f
            firstRun = False
        else:
            #print primitives
            for coeffN in primitives:
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                #print "not first:",f
                #print f,"\t\t",numsf(f)
                if not f.is_irreducible(): continue
                E = GF(orderE, name='a', modulus=f)

                if isPrimitive(E.gen(),barFactors) \
                        and isCompletelyNormal(E.gen(),E,p,\
                            divs,fieldsAll,facsAll,prodsAll):
                    return f
    # test rest
    for length in xrange(1,n-1):
        for idcs in itertools.combinations(xrange(1,n-1),length):
            #print idcs
            for xs in itertools.product(xrange(1,p),repeat=length+1):
                #print xs
                for x in primitives:
                    f = Fx.gen()**n + xs[0]*Fx.gen()**(n-1) + x
                    for j,j2 in enumerate(idcs):
                        f += xs[length-j] * Fx.gen() ** j2
                    #print f
                    if not f.is_irreducible(): continue
                    E = GF(orderE, name='a', modulus=f)

                    if isPrimitive(E.gen(),barFactors) \
                            and isCompletelyNormal(E.gen(),E,p,\
                                divs,fieldsAll,facsAll,prodsAll):
                        return f


# tests x for primitivity
def isPrimitive(x,barFactors=None):
    if barFactors==None:
        return x.multiplicative_order() == x.parent().order()-1
    else:
        for b in barFactors:
            if x**b == x.parent().one(): return False
        return True


def goodBorder(n):
    n = Integer(n)
    return ceil(find_root( \
            var('q') == \
            1/log(2)*( sum(divisors(n))-1 )*(log(2) + n*log(var('q'))), \
            1, n**4 ))


def numericExistence(p,r,n, do_factorization=False\
        , known_factorization=False):
    """
    checks if a PCN element exists by checking the inequality
    |P| >= |H| - 1
    where H is approximated

    p,r,n: GF with p^(r*n) elements will be considered
    do_factorization: If True factorization of p^(r*n) will be performed
    known_factorization: If True we'll look at yafu.thelib for the
                         factorization
    """

    p = Integer(p)
    r = Integer(r)
    n = Integer(n)
    q = p**r
    qn = q**n
    factors = []
    phis_to_fac = []
    
    if isRegular(p,r,1,n,1):
        return "Regular"
    
    # calc not normals
    divs = get_proper_subfield_divisors(p,r,n)
    notnorms = sum([ n/k*(q**(n-k)-1) for k in divs ])
    notnorms_better = sum([ qn - (q**k-1)**Integer(n/k) for k in divs]) \
            - qn + sum([ moebius(Integer(n/d))*q**d for d in divisors(n)])
    notnorms_better_2 = sum([ n/k*(q**(n-k)-q**(n-2*k))+q**(n-2*k) for k in divs]) \
            - qn + sum([ moebius(Integer(n/d))*q**d for d in divisors(n)])
    #print "--- numeric existance"
    #print "notnorms = %E"%notnorms
    #print "notnorms better = %E"%notnorms_better
    #print "notnorms better 2 = %E"%notnorms_better_2
    #print "notnorms = ",notnorms

    # check approx primitives
    #print "approx 1 = %E"%(log(2)*(qn-1)/log(2*(qn-1)))
    #if log(2)*(qn-1)/log(2*(qn-1)) > notnorms: 
        #return True
    

    # check approximation for euler_phi:
    # euler_phi(n) >= n/( e^gamma * loglog n + 3/loglog n ) 
    #print "approx 2 = %E"%((qn-1) / ( e**euler_gamma * log(log(qn-1)) + 3/log(log(qn-1))))
    #print "approx 2 = ",round((qn-1) / ( e**euler_gamma * log(log(qn-1)) + 3/log(log(qn-1))),3)
    if (qn-1) / ( e**euler_gamma * log(log(qn-1)) + 3/log(log(qn-1)) ) \
            > notnorms:
        ##print (p,r,n),"notnorms good!"
        return True
    
    if (qn-1) / ( e**euler_gamma * log(log(qn-1)) + 3/log(log(qn-1)) ) \
            > notnorms_better:
        #print "notnorms = %E"%notnorms
        #print "notnorms better = %E"%notnorms_better
        #print "notnorms better 2 = %E"%notnorms_better_2
        #print (p,r,n), "notnorms better good!"
        return True
    
    if (qn-1) / ( e**euler_gamma * log(log(qn-1)) + 3/log(log(qn-1)) ) \
            > notnorms_better_2:
        #print (p,r,n), "notnorms better 2 good!"
        return True

    
    all_good = True
    # calc primitives
    # using q**n-1 = prod_(d|r*n) Phi_d(p)
    Zx = PolynomialRing(ZZ,'x')
    for d in divisors(r*n):
        #print "d=",d," f=",Zx.cyclotomic_polynomial(d),\
                #" -> f(p)=",Zx.cyclotomic_polynomial(d)(p)
        phi = Zx.cyclotomic_polynomial(d)(p)
        if phi == 1: continue
        if yafu.thelib.is_fac_easy(phi) or is_prime(phi):
            factors += list(factor(phi))
        elif do_factorization:
            all_good = False
            factors += list(factor(phi,algorithm='ecm'))
        elif known_factorization:
            all_good = False
            factors += yafu.thelib.from_lib(phi)
        else:
            fac = yafu.thelib.from_lib(phi)
            if fac != None:
                factors += fac
            else:
                try:
                    alarm(5)
                    fac = list(factor(phi))
                    cancel_alarm()
                    factors += fac
                    yafu.thelib.to_lib(phi,fac)
                except AlarmInterrupt:
                    all_good = False
                    phis_to_fac += [phi]

    #print "factors = ", factors
    _organizeFactorization(factors)
    prims = 1
    for (f,mul) in factors:
        prims *= f**(mul-1)*(f-1)

    #print "prims = %E"%prims
    if prims > notnorms or prims > notnorms_better or prims > notnorms_better_2:
        return {"numEx":True,"all_good":all_good\
                ,"facs":factors,"phis":phis_to_fac}
        #print "prims = ",prims
    #print "prims = %E"%prims
    #print "prims2 = %E"%prims2
        #if prims > notnorms: return True
    # check factorization
    #if prod(map(lambda pr: pr[0]**pr[1], factors)) != qn-1:
        #print "FATAL ERROR on ",(p,r,n)," with factors = ",factors
    return {"numEx":False,"all_good":all_good,"facs":factors,"phis":phis_to_fac}

def _organizeFactorization(fac):
    prims = []
    ret = []
    for (p,mul) in fac:
        if not p in prims:
            prims += [p]
            ret += [(p,mul)]
        else:
            ret[prims.index(p)] = (p,ret[prims.index(p)][1] + mul)
    fac[:] = []
    fac += sorted(ret)


def primePowerGenerator(n,startq=None):
    border = goodBorder(n)
    for q in itertools.count(2):
        if startq != None and q < startq: continue
        if q > border: return
        fac = list(factor(q))
        if len(fac) == 1:
            p = fac[0][0]
            r = fac[0][1]
            yield p,r


def findAnyPCN_numeric_approx(n, startq=None, \
        fileoutput=False, filepath="out/pcns_trinom_v1.2_", \
        cpu_num=4, yafu_threads=4,\
        only_batch=False):
    """Main routine for finding PCN polynomials or proving numerical existance.

       n: degree of extension
       startq: start with F_startq
       fileoutput: write results to file
       filepath: path for output file
       cpu_num: use python multiprocessing with given number of threads
       yafu_threads: make yafu to use given number of threads
       only_batch: if True only a batch file with factoring jobs is created
                   and no other fileoutput or factorization is done
    """

    st = datetime.datetime.\
            fromtimestamp(time.time()).strftime('%Y-%m-%d_%H:%M:%S')
    batchpath = filepath+str(n)+".bat"
    if fileoutput:
        filepath += str(n)+"_"+st

    yafu.thelib.clean_lib()

    # process easy pairs
    pairs_not_easy = []
    phis_to_fac = []
    gen = primePowerGenerator(n,startq)

    def numEx__star(pr):
        p,r,pairs_not_easy,phis_to_fac = pr
        numExTup = numericExistence(p,r,n)
        if type(numExTup) is dict:
            numEx = numExTup['numEx']
            all_good = numExTup['all_good']
            facs = numExTup['facs']
            phis = numExTup['phis']
        else:
            numEx = numExTup
            facs = ""
        print "(",p,", ",r,", ",n,") = ", numEx
        if numEx != False:
            if fileoutput:
                with open(filepath,'a') as f:
                    f.write(str(p)+"\t"+str(r)+"\t"+str(numEx)\
                            +"\t"+factorization2string(facs)+"\n")
                f.close()
        else:
            pairs_not_easy += [(p,r)]
            phis_to_fac += phis

    for p,r in gen:
        numEx__star((p,r,pairs_not_easy,phis_to_fac))

    with open(batchpath,'w') as fout:
        for phi in phis_to_fac:
            fout.write(str(phi)+"\n")
    fout.close()
    
    if only_batch: return




    ##factor bad pairs
    #pool = MyPool(cpu_num)
    #pool.imap_unordered(yafu.yafu.factor_to_lib, phis_to_fac)
    #pool.close()
    #pool.join()
    for idx,phi in enumerate(phis_to_fac):
        print "INFO:\t",idx," from ",len(phis_to_fac), " done."
        yafu.yafu.factor_to_lib(phi,num_threads=yafu_threads)

    ## use factors
    pool = MyPool(cpu_num)
    for p,r,n,poly,factors in \
            pool.imap_unordered(findAnyPCN_polynom__star_prn\
            ,((p,r,n) for p,r in pairs_not_easy)):
        print "(",p,", ",r,", ",n,") = ", poly
        if fileoutput:
            with open(filepath,'a') as f:
                f.write(str(p)+"\t"+str(r) \
                        +"\t"+str(poly)\
                        +"\t"+factorization2string(factors)+"\n")
            f.close();
    pool.close()
    pool.join()

    ##clean up
    #os.remove(batchfile)


def findAnyPCN_polynom__star_prn(prnfac):
    p = prnfac[0]
    r = prnfac[1]
    n = prnfac[2]

    numExTup = numericExistence(p,r,n,known_factorization=True)
    numEx = numExTup['numEx']
    factors = numExTup['facs']
    if numEx != False:
        return p,r,n,numEx,factors
    else:
        return p,r,n,findAnyPCN_polynom(p,r,n,factors),factors

##############################################################################
## Correct data in files #####################################################
##############################################################################


def checkData(inFolder="./out/"):
    ns = []
    for fin in glob.glob(inFolder+"pcns_trinom_*"):
        ns += [Integer(re.compile("pcns_trinom_(\d+)").search(fin).groups()[0])]
    ns = uniq(ns)
    for n in ns:
        checkFiles(glob.glob(inFolder+"pcns_trinom_"+str(n)+"_*"))


def checkFiles(files, outpath="./final/pcns_"):
    data = []
    for fin in files:
        n = Integer(re.compile("pcns_trinom_(\d+)").search(fin).groups()[0])
        with open(fin) as f:
            for line in f:
                if all(c in string.whitespace for c in line): continue
                regroups = re.compile("(\d+)\s+(\d+)\s+(.+)$").search(line).groups()
                p = Integer(regroups[0])
                r = Integer(regroups[1])
                res = regroups[2]
                if isRegular(p,r,1,n,1):
                    res = "Regular"
                data += [(p,r,res)]
                #print "p=",p,"\t","r=",r,"\tres=",res
    toCheck = list(primePowerGenerator(n))
    data = sorted(data)
    fout = outpath+str(n)+".csv"
    with open(fout,'w') as f:
        f.write("p,\tr,\tresult\n")
        for p,r,res in data:
            try:
                toCheck.remove((p,r))
            except:
                print "Error on removing (p,r,n)=",(p,r,n)," on file ",files
            f.write(str(p)+",\t"+str(r)+",\t"+str(res)+"\n")
    f.close()

    print "n = ",n," missing = ",toCheck
    if len(toCheck) > 0:
        fout = outpath+"missing_"+str(n)
        with open(fout,'w') as f:
            for p,r in toCheck:
                f.write(str(p)+",\t"+str(r))
        f.close()





##############################################################################
## Slow Py Algorithms ########################################################
##############################################################################


# Tests x as Element of E on complete normality, i.e. tests for each 
# d in divs, if the corresponding polynomials in prodsAll over the corresponding
# field in fieldsAll vanishes on frobenius evaluation of x.
# fieldsAll and facsAll are dicts indexed by the divisors of divs, where
# fieldsAll[d] is the corresponding intermediate field of order q^d
# and facsAll[d] is the factorization of x^(n/d)-1 over GF(q^d).
# prodsAll[d] is the list of all possible cofactors of above factorization.
def isCompletelyNormal(x,E, q, divs, fieldsAll, facsAll, prodsAll):
    if x == E.zero(): return False
    #test isNormal for each divisor
    pows = dict()
    for d in divs:
        h = Hom(fieldsAll[d],E)[0];
        for idx,(f,mult) in enumerate(facsAll[d]):
            g = prodsAll[d][idx];
            ret = E.zero();
            iold = 0
            xiold = x
            for i,gi in enumerate(list(g)):
                if pows.has_key(i*d):
                    xi = pows[i*d];
                    iold = i*d
                    xiold = xi
                else:
                    xi = xiold**(q**(d*i-iold));
                    pows[i*d] = xi;
                    xiold = xi
                    iold = i*d
                ret += h(gi)*xi
            if ret == 0: return False;
    return True


##############################################################################
## Helper ####################################################################
##############################################################################


def get_padic_representation(number, p):
    number = Integer(number)
    p = Integer(p)
    ret = []
    q = number
    while q > 0:
        q,r = q.quo_rem(Integer(p));
        ret += [r]
    return list(reversed(ret))



# computes the quadratic free part of an integer
def squarefree(n):
    return sage.all.prod(map(lambda x: x[0], sage.all.factor(Integer(n))))

# computes ordn m(q) = min{ k: q ** k = 1 mod m }
def ordn(m,q):
    Zn = IntegerModRing(m)
    return Zn(q).multiplicative_order()

# Application of the Decomposition Theorem (Section 19)
# for x^n-1 over F_p^e
def decompose(p,e, n):
    pi = largestDiv(p,n)
    return decompose_cycl_module(p,e, 1, n/pi, pi)


## returns the module characters of a decomposition
## the module character of U_F,Phi_k(x^t) is k*t / nu(k)
def get_module_characters(decomp):
   return uniq(map(lambda l: l[0]*l[1]*l[2] / squarefree(l[0]),decomp))

# returns the module characters of a cyclotomic module
# the module character of U_F,Phi_k(x^t)^pi is k*t*pi / nu(k)
def get_module_character(k,t,pi):
    return Integer(k*t*pi/squarefree(k))

# returns all divisors of the module characters of an extension
# capped with the complete basic divisors
# i.e. all intermediate fields that must be considered
def get_proper_subfield_divisors(p,e, n):
    basList = get_not_completely_basic_divisors(p,e,n)
    return filter(lambda d: d in basList, \
            list(uniq(itertools.chain(*map(divisors,\
           get_module_characters(decompose(p,e,n)))))))


# internal application of the Decomposition Theorem
# for Phi_k(x^(t*pi)) over F_p^e
def decompose_cycl_module(p,e, k,t,pi):
    if p.divides(k*t): print "ERROR p | kt"
    #test all prime divisors, start with largest one
    flag = False
    for r,l in reversed(factor(t)):
        if not (r**l).divides(ordn(squarefree(k*t),p**e)):
            R = largestDiv(r,t)
            return decompose_cycl_module(p,e, k, t/r, pi) \
                    + decompose_cycl_module(p,e, k*R, t/R, pi)
    return [(k,t,pi)]



# returns the largest power of p dividing n
def largestDiv(p,n):
    l = 0
    while (p**l).divides(n):
        l = l+1
    return p**(l-1);


# returns the NOT completely basic divisors of an 
# extension n over GF(p^e)
def get_not_completely_basic_divisors(p,e,n):
    n = Integer(n)
    q = Integer(p**e)
    divs = []
    divsN = divisors(n)
    while len(divsN) > 0:
        d = divsN.pop(0)
        #print "d=",d
        isComplBasic = True
        for r in prime_divisors(n/d):
            #print "\tr=",r
            #print "\t\t (n/d/r)\'=",p_free_part(n/d/r,p)," ordn(_,q^d)=",\
                          #ordn(p_free_part(n/d/r,p),q**d)
            if r.divides(ordn(p_free_part(n/d/r,p),q**d)):
                #print "\t\t=> r | _"
                isComplBasic = False
                break
        divs += [d]
        if isComplBasic: 
            #print "\t -> compl basic!"
            divsN = filter(lambda k: not d.divides(k), divsN)
            #print "\t new divsN=",divsN
    return divs


# p-free part of t
def p_free_part(t,p):
    while p.divides(t):
        t /= p
    return t

# tests if cyclotomic module C_k,t is regular over F_p^e
def isRegular(p,e, k,t,pi):
    return gcd( ordn( squarefree(k*p_free_part(t,p)), p**e ),  k*t*pi) == 1



# formats timedelta objects to nice string
def strfdelta(tdelta):
    d = {}
    d["hours"], rem = divmod(tdelta.seconds, 3600)
    d["hours"] += int(tdelta.days*24)
    d["minutes"], d["seconds"] = divmod(rem, 60)
    return "{hours}:{minutes}:{seconds}".format(**d)



def tau_order(x,F, factors=[], prods=[], sigmaPower=1):
    Fx = PolynomialRing(F,'x');
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    if factors == []:
        fac = (Fx.gen()**n-1).factor();
    else:
        fac = factors;
    pows = dict();
    pre = [];
    for idx,(f,mult) in enumerate(fac):
        for j in xrange(mult-1,-1,-1):
            g = f.parent().one();
            ev = pre + [j] + map(lambda i: i[1], fac[idx+1:]);
            if prods == []:
                #generate factor
                for kidx, k in enumerate(ev):
                    g *= fac[kidx][0]**k;
            else:
                g = prods[str(ev)];
            ret = E.zero();
            for i,g in enumerate(list(g)):
                if pows != []:
                    if pows.has_key(i):
                        xi = pows[i];
                    else:
                        xi = x**(q**i);
                        pows[i] = xi;
                else: xi = x**(q**i);
                try:
                    ret += g*xi;
                except:
                    h = Hom(F,E)[0];
                    ret += h(g)*xi;
            if ret != 0:
                pre += [j+1]; 
                break;
            elif j == 0: 
                pre += [0];
    if prods == []:
        g = f.parent().one();
        for jidx, j in enumerate(pre):
            g *= fac[jidx][0]**j;
    else:
        g = prods[str(pre)]
    gshifted = [Fx.zero()]*len(list(g))
    for i, gi in enumerate(g):
        if gi == 0: continue
        gshifted[int(i/sigmaPower)] = gi
    return Fx(gshifted)


##############################################################################
## Factorization Methods #####################################################
##############################################################################

def factorization2string(factorization):
    if factorization == []: return ""
    s = ""
    for idx, (p,r) in enumerate(factorization):
        s += str(p)
        if r > 1: 
            s += "^"+str(r)
        if idx < len(factorization) - 1:
            s += " * "
    return s


def purge(dir, pattern):
    for f in os.listdir(dir):
        if re.search(pattern, f):
            os.remove(os.path.join(dir, f))

##############################################################################
## Pool in Deamon Mode #######################################################
##############################################################################

# From 
# http://stackoverflow.com/questions/6974695/python-process-pool-non-daemonic

class NoDaemonProcess(multiprocessing.Process):
    # make 'daemon' attribute always return False
    def _get_daemon(self):
        return False
    def _set_daemon(self, value):
        pass
    daemon = property(_get_daemon, _set_daemon)

# We sub-class multiprocessing.pool.Pool instead of multiprocessing.Pool
# because the latter is only a wrapper function, not a proper class.
class MyPool(multiprocessing.pool.Pool):
    Process = NoDaemonProcess
