from sage.all import factor, AlarmInterrupt, cancel_alarm, alarm, is_prime,ZZ,\
    euler_gamma, PolynomialRing, moebius, e, divisors, log, var, find_root,\
    ceil, is_even, GF
import sage.all as sage
import re
import time
from multiprocessing import Pool, Value
import multiprocessing
import multiprocessing.pool
import itertools
import datetime
import time
import os
import ast
import string
import glob
import subprocess
import yafu

def findAnyPCN_polynom(p,r,n, factors=None):
    return findAnyPCN_polynom_prime(p,r*n,factors)

# special function for testing extensions of PrimeFields
# if factors != None assume factors is a list containing the complete
# factorization of p**n-1
def findAnyPCN_polynom_prime(p,n,factors=None):
    p = sage.Integer(p)
    n = sage.Integer(n)
    F = GF(p)
    
    Fx = PolynomialRing(F,'x')
    
    orderE = p**n
    primOrder = orderE-1

    primitives = []

    #setup barFactors 
    barFactors = None
    if factors != None:
        barFactors = []
        for i,(fac,mul) in enumerate(factors):
            barFactors += [sage.prod( map(lambda fm: fm[0]**fm[1],
                    factors[:i] + [(fac,mul-1)] + factors[i+1:] ))]


    #setup factors of x^n-1
    divs = get_proper_subfield_divisors(p,1,n)
    facsAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    for d in divs:
        G = F.extension(sage.Integer(d), 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facsAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facsAll[d]):
            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]

    firstRun = True
    # first test trinoms!
    for coeffT in xrange(1,p):
        if firstRun:
            if is_even(n):
                prange = xrange(1,p)
            else:
                prange = xrange(p-1,0,-1)
            for coeffN in prange:
                if F(coeffN).multiplicative_order() != p-1: continue
                if is_even(n):
                    primitives += [coeffN]
                else:
                    coeffN *= (-1)
                    primitives = [coeffN] + primitives
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                #print f
                if not f.is_irreducible(): continue
                
                E = GF(orderE, name='a', modulus=f)

                if isPrimitive(E.gen(), barFactors) \
                        and isCompletelyNormal(E.gen(),E,p,\
                            divs,fieldsAll,facsAll,prodsAll):
                    return f
            firstRun = False
        else:
            #print primitives
            for coeffN in primitives:
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                #print "not first:",f
                #print f,"\t\t",numsf(f)
                if not f.is_irreducible(): continue
                E = GF(orderE, name='a', modulus=f)

                if isPrimitive(E.gen(),barFactors) \
                        and isCompletelyNormal(E.gen(),E,p,\
                            divs,fieldsAll,facsAll,prodsAll):
                    return f
    # test rest
    for length in xrange(1,n-1):
        for idcs in itertools.combinations(xrange(1,n-1),length):
            #print idcs
            for xs in itertools.product(xrange(1,p),repeat=length+1):
                #print xs
                for x in primitives:
                    f = Fx.gen()**n + xs[0]*Fx.gen()**(n-1) + x
                    for j,j2 in enumerate(idcs):
                        f += xs[length-j] * Fx.gen() ** j2
                    #print f
                    if not f.is_irreducible(): continue
                    E = GF(orderE, name='a', modulus=f)

                    if isPrimitive(E.gen(),barFactors) \
                            and isCompletelyNormal(E.gen(),E,p,\
                                divs,fieldsAll,facsAll,prodsAll):
                        return f


# tests x for primitivity
def isPrimitive(x,barFactors=None):
    if barFactors==None:
        return x.multiplicative_order() == x.parent().order()-1
    else:
        for b in barFactors:
            if x**b == x.parent().one(): return False
        return True


def goodBorder(n):
    n = sage.Integer(n)
    return ceil(find_root( \
            var('q') == \
            1/log(2)*( sum(divisors(n))-1 )*(log(2) + n*log(var('q'))), \
            1, n**4 ))


def numericExistence(p,r,n, do_factorization=False\
        , known_factorization=False, prime_list=None):
    """
    checks if a PCN element exists by checking the inequality
    |P| >= |H| - 1
    where H is approximated

    p,r,n: GF with p^(r*n) elements will be considered
    do_factorization: If True factorization of p^(r*n) will be performed
    known_factorization: If True we'll look at yafu.thelib for the
                         factorization
    """

    p = sage.Integer(p)
    r = sage.Integer(r)
    n = sage.Integer(n)
    q = p**r
    qn = q**n
    factors = []
    phis_to_fac = []
    
    if isRegular(p,r,1,n,1):
        return "Regular"
    
    # calc approx of not normals and primitives
    divs = get_proper_subfield_divisors__graph(p,r,n)
    #approx_notnorms = q**n - sum([ euler_polynomial(q,d,n) for d in divs]) \
            #+ (len(divs)-1)*sum([ moebius(n/k)*q**k for k in divisors(n)])
    approx_notnorms = sum( [\
        sum([ moebius(n/(d*a))*q**(d*a) for a in divisors(sage.Integer(n/d))]) 
        -euler_polynomial(q,d,n) for d in divs ] )

    approx_prims = (qn-1) / ( e**euler_gamma * \
            log(log(qn-1)) + 3/log(log(qn-1)) )
    
    if approx_prims > approx_notnorms:
        return True

    
    all_good = True
    if prime_list == None: prime_list = yafu.thelib.prime_list()
    # calc primitives
    # using q**n-1 = prod_(d|r*n) Phi_d(p)
    Zx = PolynomialRing(ZZ,'x')
    for d in divisors(r*n):
        #print "d=",d," f=",Zx.cyclotomic_polynomial(d),\
                #" -> f(p)=",Zx.cyclotomic_polynomial(d)(p)
        phi = Zx.cyclotomic_polynomial(d)(p)
        if phi == 1: continue

        # try to pre-fac phi
        for s in prime_list:
            s_count = 0
            while sage.Integer(s).divides(phi):
                s_count += 1
                phi = sage.Integer(phi/s)
            if s_count > 0: factors += [(s,s_count)]

        if yafu.thelib.is_fac_easy(phi) or is_prime(phi):
            factors += list(factor(phi))
        elif do_factorization:
            all_good = False
            factors += list(factor(phi,algorithm='ecm'))
        elif known_factorization:
            all_good = False
            factors += yafu.thelib.from_lib(phi)
        else:
            fac = yafu.thelib.from_lib(phi)
            if fac != None:
                factors += fac
            else:
                try:
                    alarm(5)
                    fac = list(factor(phi))
                    cancel_alarm()
                    factors += fac
                    yafu.thelib.to_lib(phi,fac)
                except AlarmInterrupt:
                    all_good = False
                    phis_to_fac += [phi]

    #print "factors = ", factors
    _organizeFactorization(factors)
    prims = 1
    for (f,mul) in factors:
        prims *= f**(mul-1)*(f-1)

    #print "prims = %E"%prims
    if prims > approx_notnorms:
        return {"numEx":True,"all_good":all_good\
                ,"facs":factors,"phis":phis_to_fac}
        #print "prims = ",prims
    #print "prims = %E"%prims
    # check factorization
    return {"numEx":False,"all_good":all_good,"facs":factors,"phis":phis_to_fac}

def _organizeFactorization(fac):
    prims = []
    ret = []
    for (p,mul) in fac:
        if not p in prims:
            prims += [p]
            ret += [(p,mul)]
        else:
            ret[prims.index(p)] = (p,ret[prims.index(p)][1] + mul)
    fac[:] = []
    fac += sorted(ret)


def primePowerGenerator(n,startq=None):
    border = goodBorder(n)
    for q in itertools.count(2):
        if startq != None and q < startq: continue
        if q > border: return
        fac = list(factor(q))
        if len(fac) == 1:
            p = fac[0][0]
            r = fac[0][1]
            yield p,r


def findAnyPCN_numeric_approx(n, startq=None, \
        fileoutput=False, filepath="out/pcns_trinom_v1.3_", \
        cpu_num=4, yafu_threads=4,\
        only_batch=False, batchpath="out/tofactor_"):
    """Main routine for finding PCN polynomials or proving numerical existance.

       n: degree of extension
       startq: start with F_startq
       fileoutput: write results to file
       filepath: path for output file
       cpu_num: use python multiprocessing with given number of threads
       yafu_threads: make yafu to use given number of threads
       only_batch: if True only a batch file with factoring jobs is created
                   and no other fileoutput or factorization is done
    """

    st = datetime.datetime.\
            fromtimestamp(time.time()).strftime('%Y-%m-%d_%H:%M:%S')
    batchpath += str(n)
    if fileoutput:
        filepath += str(n)+"_"+st

    yafu.thelib.clean_lib()
    prime_list = yafu.thelib.prime_list()

    # process easy pairs
    pairs_not_easy = []
    phis_to_fac = []
    gen = primePowerGenerator(n,startq)
    
    global lastTwenty
    lastTwenty = 0

    def numEx__star(pr):
        global lastTwenty
        p,r,pairs_not_easy,phis_to_fac = pr
        numExTup = numericExistence(p,r,n,prime_list=prime_list)
        if type(numExTup) is dict:
            numEx = numExTup['numEx']
            all_good = numExTup['all_good']
            facs = numExTup['facs']
            phis = numExTup['phis']
        else:
            numEx = numExTup
            facs = ""
        #print "(",p,", ",r,", ",n,") = ", numExTup
        if numEx != False:
            lastTwenty += 1
            if lastTwenty == 20: return True
            if fileoutput:
                with open(filepath,'a') as f:
                    f.write(str(p)+"\t"+str(r)+"\t"+str(numEx)\
                            +"\t"+factorization2string(facs)+"\n")
                f.close()
        else:
            lastTwenty = 0
            pairs_not_easy += [(p,r)]
            phis_to_fac += phis

    for p,r in gen:
        if numEx__star((p,r,pairs_not_easy,phis_to_fac)): break
    
    phis_to_fac = sage.uniq(phis_to_fac)
    #print "phis_to_fac: ", phis_to_fac
    print "len: ", map(lambda n: ceil(log(n,2)),phis_to_fac)
    if len(phis_to_fac) > 0:
        with open(batchpath,'w') as fout:
            for phi in phis_to_fac:
                fout.write(str(phi)+"\n")
        fout.close()
    
    if only_batch: return


    ##factor bad pairs
    #pool = MyPool(cpu_num)
    #pool.imap_unordered(yafu.yafu.factor_to_lib, phis_to_fac)
    #pool.close()
    #pool.join()
    for idx,phi in enumerate(phis_to_fac):
        print "INFO:\t",idx," from ",len(phis_to_fac), " done."
        yafu.yafu.factor_to_lib(phi,num_threads=yafu_threads)

    ## use factors
    pool = MyPool(cpu_num)
    for p,r,n,poly,factors in \
            pool.imap_unordered(findAnyPCN_polynom__star_prn\
            ,((p,r,n) for p,r in pairs_not_easy)):
        print "(",p,", ",r,", ",n,") = ", poly
        if fileoutput:
            with open(filepath,'a') as f:
                f.write(str(p)+"\t"+str(r) \
                        +"\t"+str(poly)\
                        +"\t"+factorization2string(factors)+"\n")
            f.close();
    pool.close()
    pool.join()

    ##clean up
    #os.remove(batchfile)


def findAnyPCN_polynom__star_prn(prnfac):
    p = prnfac[0]
    r = prnfac[1]
    n = prnfac[2]

    numExTup = numericExistence(p,r,n,known_factorization=True)
    numEx = numExTup['numEx']
    factors = numExTup['facs']
    if numEx != False:
        return p,r,n,numEx,factors
    else:
        return p,r,n,findAnyPCN_polynom(p,r,n,factors),factors



##############################################################################
## Mullen and Morgan search ##################################################
##############################################################################


def findAnyPCN__mullen_level(\
        #pRange=[2,97], rRange=[1,1], nRange=[2,10**50], border=10**50,\
        pRange=[2,1000], rRange=[1,10**70], nRange=[2,10**70], border=10**70,\
        not_condition=None,\
        cpuNum=1, fileoutput=False, filepath="pcns_range_v1.3_"):
    if fileoutput:
        st = datetime.datetime.\
                fromtimestamp(time.time()).strftime('%Y-%m-%d_%H:%M:%S')
    
    gen = runGeneratorMullen(border,pRange,rRange,nRange,not_condition)
    
    pool = Pool(cpuNum)
    for p,r,n,pol,fac in pool.imap_unordered(\
                            findAnyPCN_polynom_range__star, gen):
        print "(",p,", ",r,", ",n, ") = ", pol
        if fileoutput:
            with open(filepath+st,'a') as f:
                f.write(str(p)+"\t"+str(r)+"\t"+str(n)\
                        +"\t"+str(pol)\
                        +"\t"+factorization2string(fac)+"\n")
            f.close();
    pool.close()
    pool.join()


def findAnyPCN__mullen_level__yafu(\
        #pRange=[2,97], rRange=[1,1], nRange=[2,10**50], border=10**50,\
        pRange=[2,97], rRange=[1,1], nRange=[2,10**50], border=10**50,\
        #pRange=[2,1000], rRange=[1,10**70], nRange=[2,10**70], border=10**70,\
        not_condition=None,\
        cpuNum=1, fileoutput=False, filepath="out/pcns_range_v1.3_"):
    if fileoutput:
        st = datetime.datetime.\
                fromtimestamp(time.time()).strftime('%Y-%m-%d_%H:%M:%S')
    
    gen = runGeneratorMullen(border,pRange,rRange,nRange,not_condition)
    
    Zx = PolynomialRing(ZZ,'x')
    for p,r,n in gen:
        # setup factorization
        fac = []
        for d in divisors(r*n):
            phi = Zx.cyclotomic_polynomial(d)(p)
            if phi == 1: continue
            if is_prime(phi) or yafu.thelib.is_fac_easy(phi):
                fac += list(factor(phi, algorithm='ecm'))
            else:
                yaf_fac = yafu.yafu.factor_to_lib(phi,num_threads=cpuNum)[1]
                fac += yaf_fac
        _organizeFactorization(fac)
        # find poly
        pol = findAnyPCN_polynom(p,r,n,fac)
        # print result and write to file
        print "(",p,", ",r,", ",n, ") = ", pol
        if fileoutput:
            with open(filepath+st,'a') as f:
                f.write(str(p)+"\t"+str(r)+"\t"+str(n)\
                        +"\t"+str(pol)\
                        +"\t"+factorization2string(fac)+"\n")
            f.close();

def runGeneratorMullen(border,pRange,rRange,nRange,not_condition):
    stopP = pRange[1]
    startP = pRange[0]
    startR = rRange[0]
    stopR = rRange[1]
    startN = nRange[0]
    stopN = nRange[1]
    if not is_prime(startP): startP = sage.next_prime(startP)
    p = startP
    r = startR
    n = startN
    while True:
        q = p**r
        if not_condition == None or \
                not not_condition(sage.Integer(p),sage.Integer(r),sage.Integer(n)):
            yield sage.Integer(p),sage.Integer(r),sage.Integer(n)
        n += 1
        if n > stopN or p**(r*n) > border:
            n = startN
            r += 1
            if r > stopR or p**(r*n) > border: 
                r = startR
                p = sage.next_prime(p)
                if p > stopP: return


def findAnyPCN_polynom_range__star(prn):
    p,r,n = prn
    # factor n
    Zx = PolynomialRing(ZZ,'x')
    fac = []
    for d in divisors(r*n):
        fac += list(factor(Zx.cyclotomic_polynomial(d)(p), algorithm='ecm'))
    _organizeFactorization(fac)
    return p,r,n,findAnyPCN_polynom(p,r,n,fac),fac






##############################################################################
## Slow Py Algorithms ########################################################
##############################################################################

def euler_polynomial(q, d, n):
    """
    returns phi_(q^d)(x^(n/d)-1)
    where phi_q is the polynomial analogon for the euler totient function

    q: cardinality of a finite field (i.e. must be a prime power)
    d: degree of extension of GF(q)
    n: degree of total extension
    """
    p = sage.prime_divisors(q)[0]
    tau = sage.Integer(n/d)
    while p.divides(tau): tau = sage.Integer(tau/p)

    return q**(n-d*tau) * \
            sage.prod( [ (q**(d*ordn(e,q**d)) - 1)**(sage.euler_phi(e)/ordn(e,q**d))\
            for e in divisors(tau) ] )


def isCompletelyNormal(x,E, q, divs, fieldsAll, facsAll, prodsAll):
    """
    Tests x as Element of E on complete normality, i.e. tests for each 
    d in divs, if the corresponding polynomials in prodsAll over the corresponding
    field in fieldsAll vanishes on frobenius evaluation of x.
    fieldsAll and facsAll are dicts indexed by the divisors of divs, where
    fieldsAll[d] is the corresponding intermediate field of order q^d
    and facsAll[d] is the factorization of x^(n/d)-1 over GF(q^d).
    prodsAll[d] is the list of all possible cofactors of above factorization.
    """
    if x == E.zero(): return False
    #test isNormal for each divisor
    pows = dict()
    for d in divs:
        h = sage.Hom(fieldsAll[d],E)[0];
        for idx,(f,mult) in enumerate(facsAll[d]):
            g = prodsAll[d][idx];
            ret = E.zero();
            iold = 0
            xiold = x
            for i,gi in enumerate(list(g)):
                if pows.has_key(i*d):
                    xi = pows[i*d];
                    iold = i*d
                    xiold = xi
                else:
                    xi = xiold**(q**(d*i-iold));
                    pows[i*d] = xi;
                    xiold = xi
                    iold = i*d
                ret += h(gi)*xi
            if ret == 0: return False;
    return True


##############################################################################
## Helper ####################################################################
##############################################################################


def get_padic_representation(number, p):
    number = sage.Integer(number)
    p = sage.Integer(p)
    ret = []
    q = number
    while q > 0:
        q,r = q.quo_rem(sage.Integer(p));
        ret += [r]
    return list(reversed(ret))



# computes the quadratic free part of an integer
def squarefree(n):
    return sage.prod(map(lambda x: x[0], sage.all.factor(sage.Integer(n))))

# computes ordn m(q) = min{ k: q ** k = 1 mod m }
def ordn(m,q):
    Zn = sage.IntegerModRing(m)
    return Zn(q).multiplicative_order()

# Application of the Decomposition Theorem (Section 19)
# for x^n-1 over F_p^e
def decompose(p,e, n):
    pi = largestDiv(p,n)
    return decompose_cycl_module(p,e, 1, n/pi, pi)


## returns the module characters of a decomposition
## the module character of U_F,Phi_k(x^t) is k*t / nu(k)
def get_module_characters(decomp):
   return sage.uniq(map(lambda l: l[0]*l[1]*l[2] / squarefree(l[0]),decomp))

# returns the module characters of a cyclotomic module
# the module character of U_F,Phi_k(x^t)^pi is k*t*pi / nu(k)
def get_module_character(k,t,pi):
    return sage.Integer(k*t*pi/squarefree(k))

# returns all divisors of the module characters of an extension
# capped with the complete basic divisors
# i.e. all intermediate fields that must be considered
def get_proper_subfield_divisors(p,e, n):
    basList = get_not_completely_basic_divisors(p,e,n)
    return filter(lambda d: d in basList, \
            list(sage.uniq(itertools.chain(*map(divisors,\
           get_module_characters(decompose(p,e,n)))))))


# internal application of the Decomposition Theorem
# for Phi_k(x^(t*pi)) over F_p^e
def decompose_cycl_module(p,e, k,t,pi):
    if p.divides(k*t): print "ERROR p | kt"
    #test all prime divisors, start with largest one
    flag = False
    for r,l in reversed(factor(t)):
        if not (r**l).divides(ordn(squarefree(k*t),p**e)):
            R = largestDiv(r,t)
            return decompose_cycl_module(p,e, k, t/r, pi) \
                    + decompose_cycl_module(p,e, k*R, t/R, pi)
    return [(k,t,pi)]



# returns the largest power of p dividing n
def largestDiv(p,n):
    l = 0
    while (p**l).divides(n):
        l = l+1
    return p**(l-1);


# returns the NOT completely basic divisors of an 
# extension n over GF(p^e)
def get_not_completely_basic_divisors(p,e,n):
    n = sage.Integer(n)
    q = sage.Integer(p**e)
    divs = []
    divsN = divisors(n)
    while len(divsN) > 0:
        d = divsN.pop(0)
        #print "d=",d
        isComplBasic = True
        for r in sage.prime_divisors(n/d):
            #print "\tr=",r
            #print "\t\t (n/d/r)\'=",p_free_part(n/d/r,p)," ordn(_,q^d)=",\
                          #ordn(p_free_part(n/d/r,p),q**d)
            if r.divides(ordn(p_free_part(n/d/r,p),q**d)):
                #print "\t\t=> r | _"
                isComplBasic = False
                break
        divs += [d]
        if isComplBasic: 
            #print "\t -> compl basic!"
            divsN = filter(lambda k: not d.divides(k), divsN)
            #print "\t new divsN=",divsN
    return divs


def get_proper_subfield_divisors__graph(p,e,n):
    p = sage.Integer(p)
    e = sage.Integer(e)
    n = sage.Integer(n)
    q = sage.Integer(p**e)
    if isRegular(p,e,1,n,1): return "isRegular"
    divsN = divisors(n)[:-1]
    adjfunc = (lambda i,j:\
        i.divides(j) and is_prime(sage.Integer(j/i)) and \
                not sage.Integer(j/i).divides(ordn(p_free_part(n/j,p),q**i)))
    g = sage.DiGraph([divsN, adjfunc])
    #g.show()
    verts_indegzero = filter(lambda v: \
            g.in_degree(vertices=[v]) == [0], g.vertices())
    #adjfunc2 = (lambda j,i:\
        #sage.Integer(i).divides(j) and is_prime(sage.Integer(j/i)) and \
        #ordn(p_free_part(n/i,p),q**i) == sage.Integer(j/i)*ordn(p_free_part(n/j,p),q**i) )
    #g2 = sage.DiGraph([verts_indegzero,adjfunc2])
    #g2.show()
    #verts_indegzero2 = filter(lambda v: \
            #g2.in_degree(vertices=[v]) == [0], g2.vertices())
    #if verts_indegzero2 != verts_indegzero:
        #print "case found on: ",(p,e,n)
        #return g,g2
    divsModChar = list(sage.uniq(itertools.chain(*map(divisors,\
        get_module_characters(decompose(p,e,n))))))
    return filter(lambda d: d in divsModChar, verts_indegzero)


def get_universal_essential_set(n):
    n = sage.Integer(n)
    prims = sage.prime_divisors(n)
    prims_good = filter(lambda r: not any([ r.divides(s-1) for s in prims])\
            , prims)
    prims_good = dict((r,get_multiplicity(r,n)) for r in prims_good)
    #print "prims_good", prims_good
    divsN = divisors(n)[:-1]
    adjfunc = (lambda i,j: 
            i.divides(j) and (sage.Integer(j/i) in prims_good) and\
            ((get_multiplicity(sage.Integer(j/i),i) == prims_good[sage.Integer(j/i)]-1\
             and get_multiplicity(sage.Integer(j/i),j) == prims_good[sage.Integer(j/i)])\
            or
            (get_multiplicity(sage.Integer(j/i),i) == prims_good[sage.Integer(j/i)]-2\
             and get_multiplicity(sage.Integer(j/i),j) == prims_good[sage.Integer(j/i)]-1)\
            ))
    g = sage.DiGraph([divsN, adjfunc])
    verts_indegzero = filter(lambda v: \
            g.in_degree(vertices=[v]) == [0], g.vertices())
    #g.show()
    return verts_indegzero


def test_univ():
    ns = [ 100, 102, 104, 105, 106, 108, 110, 111, 112, 114, 115, 116, 117, 
            118, 119, 120, 122, 123, 124, 125, 126, 129, 130, 132, 133, 134, 135, 136, 
            138, 140, 141, 142, 143, 144, 145, 146, 147, 148, 150, 152, 153, 154 ]
    for n in ns:
        univ = set(get_universal_essential_set(n))
        for p,r in primePowerGenerator(n):
            if p > 1000: break
            if isRegular(p,r,1,n,1): continue
            if not set(get_proper_subfield_divisors__graph(p,r,n)) <= univ:
                print "ERROR on ", (p,r,n)






def get_multiplicity(p,n):
    """
    returns multiplicity of p in n
    """
    a = 0
    while p.divides(n):
        a += 1
        n = sage.Integer(n/p)
    return a




# p-free part of t
def p_free_part(t,p):
    while p.divides(t):
        t /= p
    return t

# tests if cyclotomic module C_k,t is regular over F_p^e
def isRegular(p,e, k,t,pi):
    return sage.gcd( ordn( squarefree(k*p_free_part(t,p)), p**e ),  k*t*pi) == 1



# formats timedelta objects to nice string
def strfdelta(tdelta):
    d = {}
    d["hours"], rem = divmod(tdelta.seconds, 3600)
    d["hours"] += int(tdelta.days*24)
    d["minutes"], d["seconds"] = divmod(rem, 60)
    return "{hours}:{minutes}:{seconds}".format(**d)



def tau_order(x,F, factors=[], prods=[], sigmaPower=1):
    Fx = PolynomialRing(F,'x');
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    if factors == []:
        fac = (Fx.gen()**n-1).factor();
    else:
        fac = factors;
    pows = dict();
    pre = [];
    for idx,(f,mult) in enumerate(fac):
        for j in xrange(mult-1,-1,-1):
            g = f.parent().one();
            ev = pre + [j] + map(lambda i: i[1], fac[idx+1:]);
            if prods == []:
                #generate factor
                for kidx, k in enumerate(ev):
                    g *= fac[kidx][0]**k;
            else:
                g = prods[str(ev)];
            ret = E.zero();
            for i,g in enumerate(list(g)):
                if pows != []:
                    if pows.has_key(i):
                        xi = pows[i];
                    else:
                        xi = x**(q**i);
                        pows[i] = xi;
                else: xi = x**(q**i);
                try:
                    ret += g*xi;
                except:
                    h = sage.Hom(F,E)[0];
                    ret += h(g)*xi;
            if ret != 0:
                pre += [j+1]; 
                break;
            elif j == 0: 
                pre += [0];
    if prods == []:
        g = f.parent().one();
        for jidx, j in enumerate(pre):
            g *= fac[jidx][0]**j;
    else:
        g = prods[str(pre)]
    gshifted = [Fx.zero()]*len(list(g))
    for i, gi in enumerate(g):
        if gi == 0: continue
        gshifted[int(i/sigmaPower)] = gi
    return Fx(gshifted)


##############################################################################
## Factorization Methods #####################################################
##############################################################################

def factorization2string(factorization):
    if factorization == []: return ""
    s = ""
    for idx, (p,r) in enumerate(factorization):
        s += str(p)
        if r > 1: 
            s += "^"+str(r)
        if idx < len(factorization) - 1:
            s += " * "
    return s


def purge(dir, pattern):
    for f in os.listdir(dir):
        if re.search(pattern, f):
            os.remove(os.path.join(dir, f))

##############################################################################
## Pool in Deamon Mode #######################################################
##############################################################################

# From 
# http://stackoverflow.com/questions/6974695/python-process-pool-non-daemonic

class NoDaemonProcess(multiprocessing.Process):
    # make 'daemon' attribute always return False
    def _get_daemon(self):
        return False
    def _set_daemon(self, value):
        pass
    daemon = property(_get_daemon, _set_daemon)

# We sub-class multiprocessing.pool.Pool instead of multiprocessing.Pool
# because the latter is only a wrapper function, not a proper class.
class MyPool(multiprocessing.pool.Pool):
    Process = NoDaemonProcess




##############################################################################
## Correct data in files #####################################################
##############################################################################


def checkData(inFolder="./out/", infile_prefix="pcns_trinom_v1.3_"):
    ns = []
    for fin in glob.glob(inFolder+infile_prefix+"*"):
        ns += [sage.Integer(re.compile(infile_prefix+"(\d+)").search(fin).groups()[0])]
    ns = sage.uniq(ns)
    for n in ns:
        checkFiles(glob.glob(inFolder+infile_prefix+str(n)+"_*"),\
                infile_prefix=infile_prefix)


def checkFiles(files, outpath="./final/pcns_",infile_prefix="pcns_trinom_v1.3_"):
    data = []
    if not files or len(files) == 0: return
    for fin in files:
        n = sage.Integer(re.compile(infile_prefix+"(\d+)").search(fin).groups()[0])
        with open(fin) as f:
            for line in f:
                if all(c in string.whitespace for c in line): continue
                regroups = re.search("(\d+)\s+(\d+)\s+(.+)$",line)
                if not regroups: continue
                regroups = regroups.groups()
                p = sage.Integer(regroups[0])
                r = sage.Integer(regroups[1])
                res = regroups[2]
                if isRegular(p,r,1,n,1):
                    res = "Regular"
                data += [(p,r,res)]
                #print "p=",p,"\t","r=",r,"\tres=",res
    toCheck = list(primePowerGenerator(n))
    data = sorted(data)
    fout = outpath+str(n)+".csv"
    with open(fout,'w') as f:
        f.write("p,\tr,\tresult\n")
        for p,r,res in data:
            try:
                toCheck.remove((p,r))
            except:
                pass
                #print "Error on removing (p,r,n)=",(p,r,n)," on file ",files
            f.write(str(p)+",\t"+str(r)+",\t"+str(res)+"\n")
    f.close()

    if os.path.exists(outpath+"missing_"+str(n)):
        os.remove(outpath+"missing_"+str(n))
    print "n = ",n," missing = ",toCheck
    if len(toCheck) > 0:
        fout = outpath+"missing_"+str(n)
        with open(fout,'w') as f:
            for p,r in toCheck:
                f.write(str(p)+",\t"+str(r))
        f.close()


def checkRangeFiles(pRange=[2,10000],rRange=[1,10**80],nRange=[2,10**80],\
        border=10**80, infileprefix="./out/pcns_range_v1.3_",\
        outpath="./final/range/pcns_"):
    gen = runGeneratorMullen(border,pRange,rRange,nRange,\
            not_condition=None)
    values = dict()
    for f in glob.glob(infileprefix+"*"):
        with open(f) as fin:
            for line in fin:
                splits = line.split("\t")
                p = sage.Integer(splits[0])
                r = sage.Integer(splits[1])
                n = sage.Integer(splits[2])
                pol = splits[3].strip()
                fac = splits[4].strip()
                values[(p,r,n)] = (pol,fac)
        fin.close()

    lastP = 1
    for p,r,n in gen:
        if not values.has_key((p,r,n)):
            print "missing ", p,r,n
            lastP = p
            continue
        if p != lastP:
            fileout = outpath+str(p)+".csv"
            with open(fileout,'w') as fout:
                fout.write("p,r,n,poly,factorization\n")
            fout.close()
        pol,fac = values[(p,r,n)]

        with open(fileout,'a') as fout:
            fout.write(str(p)+","+str(r)+","+str(n)+","\
                    +str(pol)+","+str(fac)+"\n")
        fout.close()

        lastP = p


##############################################################################
## Check final data for special conditions ###################################
##############################################################################

FINAL_PATH="./final/pcns_"

def get_ever_true_borders():
    borders = []
    for f in glob.glob(FINAL_PATH+"*.csv"):
        #print "process "+f
        n = sage.Integer(re.search("pcns_(\d+).csv",f).groups()[0])
        with open(f) as fin:
            whole_file = fin.read().split("\n")
        fin.close()
        whole_file = list(reversed(whole_file[1:])) # we do not need the title line
        has_border = False
        for idx, l in enumerate(whole_file):
            if all(c in string.whitespace for c in l): continue
            p,r,res = parse_data(l)
            #print "parsed: \""+str(p)+"\" \""+str(r)+"\" \""+str(res)+"\""
            if res == "Regular" or res == "True":
                continue
            else: 
                #print "border found!"
                has_border = True
                break
        if has_border:
            for i in range(idx-1,0,-1):
                p,r,res = parse_data(whole_file[i])
                if res == "True":
                    borders += [(n,p**r)]
                    break
    return borders


def parse_data(data_line):
    """
    parses data where data_line must be a line in a final output file
    returns p,r,result if result equals "True" or "Regular"
    returns p,r,(pol,fac) otherwise
    """
    #print "parse "+data_line
    data = data_line.split(",")
    p = sage.Integer(data[0])
    r = sage.Integer(data[1])
    if len(data) == 3:
        res = data[2]
        return p,r,res.strip()
    elif len(data) == 4:
        pol = data[2]
        fac = data[3]
        return p,r,(pol.strip(),fac.strip())
    else:
        raise ValueError("Error on data line: "+str(data_line))



